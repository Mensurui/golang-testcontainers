name: TestContainers

on:
  push:
  pull_request:

jobs:
  Build:
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository
      - uses: actions/checkout@v4

      # Build the Docker image
      - name: Build Docker image
        run: docker build . --file Dockerfile --tag gotestcon

      # Login to DockerHub
      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Push the Docker image to DockerHub
      - name: Push Docker image to DockerHub
        run: |
          docker tag gotestcon ${{ secrets.DOCKER_USERNAME }}/gotestcon:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/gotestcon:latest
  Test:
    runs-on: ubuntu-latest
    needs: Build

    steps:
      # Step 1: Set up PostgreSQL service
      - name: Set up PostgreSQL service
        run: |
          docker network create app-network
          docker run -d --name postgres-container \
            --network app-network \
            -e POSTGRES_USER=testcontainer \
            -e POSTGRES_PASSWORD=testcontainer123 \
            -e POSTGRES_DB=testcontainersdb \
            --health-cmd="pg_isready -U testcontainer" \
            --health-interval=10s \
            --health-timeout=5s \
            --health-retries=5 \
            postgres:latest

      # Step 2: Wait for PostgreSQL to be ready
      - name: Wait for PostgreSQL readiness
        run: |
          for i in {1..10}; do
            if docker exec postgres-container pg_isready -U testcontainer; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

      # Step 3: Run the application container
      - name: Start application container
        run: |
          docker run -e TESTCONADDR='postgres://testcontainer:testcontainer123@postgres-container:5432/testcontainersdb?sslmode=disable' \
            --network app-network \
            -d --name gotestcon-container \
                        ${{ secrets.DOCKER_USERNAME }}/gotestcon:latest

      # Step 4: Debug application container logs if it fails
      - name: Check application logs
        run: |
          if [ "$(docker inspect -f '{{.State.Running}}' gotestcon-container)" != "true" ]; then
            echo "Application container failed to start. Logs:"
            docker logs gotestcon-container || true
            exit 1
          fi

      - name: Run docker
        run: |
          docker run -e TESTCONADDR='postgres://testcontainer:testcontainer123@postgres:5432/testcontainersdb?sslmode=disable' \
          -e TESTPORTADDR=':50051' \
          --network app-network \
          gotestcon-container \
              ${{ secrets.DOCKER_USERNAME }}/gotestcon:latest


      # Step 5: Run tests inside the container
      - name: Run tests
        run: docker exec gotestcon-container go test -v ./...

      # Step 6: Cleanup resources
      - name: Cleanup
        run: |
          docker stop gotestcon-container || true
          docker rm gotestcon-container || true
          docker stop postgres-container || true
          docker rm postgres-container || true
          docker network rm app-network || true

  Build-and-Test-Dockercompose:
    runs-on: ubuntu-latest
    needs: Test

    services:
      postgres:
        image: postgres:17
        ports:
          - 5433:5432
        options: >-
          --health-cmd="pg_isready -U testcontainer"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5
    steps:
      - name: Check out my code
        uses: actions/checkout@v4

      - name: Setup Docker Compose
        run: |
          docker compose up -d

      - name: Wait for services to be healthy
        run: docker compose ps
      
      - name: Run Migrations
        run: |
          docker compose run migrate
      
      - name: Run Tests
        run: |
          docker-compose run goapp go test ./...

      - name: Tear down Docker Compose
        if: always()
        run: docker-compose down
